{"version":3,"sources":["../../../../../../src/start/server/metro/inspector-proxy/device.ts"],"sourcesContent":["import type { DebuggerInfo, Device as MetroDevice } from 'metro-inspector-proxy';\nimport fetch from 'node-fetch';\nimport type WS from 'ws';\n\nimport { MetroBundlerDevServer } from '../MetroBundlerDevServer';\nimport { NetworkResponseHandler } from './handlers/NetworkResponse';\nimport { PageReloadHandler } from './handlers/PageReload';\nimport { VscodeDebuggerGetPossibleBreakpointsHandler } from './handlers/VscodeDebuggerGetPossibleBreakpoints';\nimport { VscodeDebuggerScriptParsedHandler } from './handlers/VscodeDebuggerScriptParsed';\nimport { VscodeDebuggerSetBreakpointByUrlHandler } from './handlers/VscodeDebuggerSetBreakpointByUrl';\nimport { VscodeRuntimeGetPropertiesHandler } from './handlers/VscodeRuntimeGetProperties';\nimport { DeviceRequest, InspectorHandler, DebuggerRequest } from './handlers/types';\n\n/** Export the supported debugger types this inspector proxy can handle */\nexport type DebuggerType = 'vscode' | 'generic';\n\n/** The debugger information being tracked by this device class */\nexport type ExpoDebuggerInfo = DebuggerInfo & { debuggerType?: DebuggerType };\n\nexport function createInspectorDeviceClass(\n  metroBundler: MetroBundlerDevServer,\n  MetroDeviceClass: typeof MetroDevice\n) {\n  return class ExpoInspectorDevice extends MetroDeviceClass implements InspectorHandler {\n    /** Stores information about currently connected debugger (if any). */\n    _debuggerConnection: ExpoDebuggerInfo | null = null;\n\n    /** All handlers that should be used to intercept or reply to CDP events */\n    public handlers: InspectorHandler[] = [\n      // Generic handlers\n      new NetworkResponseHandler(),\n      new PageReloadHandler(metroBundler),\n      // Vscode-specific handlers\n      new VscodeDebuggerGetPossibleBreakpointsHandler(),\n      new VscodeDebuggerScriptParsedHandler(this),\n      new VscodeDebuggerSetBreakpointByUrlHandler(),\n      new VscodeRuntimeGetPropertiesHandler(),\n    ];\n\n    onDeviceMessage(message: any, info: DebuggerInfo): boolean {\n      return this.handlers.some((handler) => handler.onDeviceMessage?.(message, info) ?? false);\n    }\n\n    onDebuggerMessage(message: any, info: DebuggerInfo): boolean {\n      return this.handlers.some((handler) => handler.onDebuggerMessage?.(message, info) ?? false);\n    }\n\n    /**\n     * Handle a new device connection with the same device identifier.\n     * When the app and device name matches, we can reuse the debugger connection.\n     * Else, we have to shut the debugger connection down.\n     */\n    handleDuplicateDeviceConnection(newDevice: InstanceType<typeof MetroDeviceClass>) {\n      if (this._app !== newDevice._app || this._name !== newDevice._name) {\n        this._deviceSocket.close();\n        this._debuggerConnection?.socket.close();\n        return;\n      }\n\n      const oldDebugger = this._debuggerConnection;\n      this._debuggerConnection = null;\n\n      if (oldDebugger) {\n        oldDebugger.socket.removeAllListeners();\n        this._deviceSocket.close();\n        newDevice.handleDebuggerConnection(oldDebugger.socket, oldDebugger.pageId);\n      }\n    }\n\n    /**\n     * Handle a new debugger connection to this device.\n     * This adds the `debuggerType` property to the `DebuggerInfo` object.\n     * With that information, we can enable or disable debugger-specific handlers.\n     */\n    handleDebuggerConnectionWithType(socket: WS, pageId: string, debuggerType: DebuggerType): void {\n      this.handleDebuggerConnection(socket, pageId);\n\n      if (this._debuggerConnection) {\n        this._debuggerConnection.debuggerType = debuggerType;\n      }\n    }\n\n    /** Hook into the message life cycle to answer more complex CDP messages */\n    async _processMessageFromDevice(message: DeviceRequest<any>, info: DebuggerInfo) {\n      if (!this.onDeviceMessage(message, info)) {\n        await super._processMessageFromDevice(message, info);\n      }\n    }\n\n    /** Hook into the message life cycle to answer more complex CDP messages */\n    _interceptMessageFromDebugger(\n      request: DebuggerRequest,\n      info: DebuggerInfo,\n      socket: WS\n    ): boolean {\n      // Note, `socket` is the exact same as `info.socket`\n      if (this.onDebuggerMessage(request, info)) {\n        return true;\n      }\n\n      return super._interceptMessageFromDebugger(request, info, socket);\n    }\n\n    /**\n     * Overwrite the default text fetcher, to load sourcemaps from sources other than `localhost`.\n     * @todo Cedric: remove the custom `DebuggerScriptSource` handler when switching over to `metro@>=0.75.1`\n     * @see https://github.com/facebook/metro/blob/77f445f1bcd2264ad06174dbf8d542bc75834d29/packages/metro-inspector-proxy/src/Device.js#L573-L588\n     * @since metro-inspector-proxy@0.75.1\n     */\n    async _fetchText(url: URL): Promise<string> {\n      const LENGTH_LIMIT_BYTES = 350_000_000; // 350mb\n\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`Received status ${response.status} while fetching: ${url}`);\n      }\n\n      const contentLength = response.headers.get('Content-Length');\n      if (contentLength && Number(contentLength) > LENGTH_LIMIT_BYTES) {\n        throw new Error('Expected file size is too large (more than 350mb)');\n      }\n\n      const text = await response.text();\n      if (Buffer.byteLength(text, 'utf8') > LENGTH_LIMIT_BYTES) {\n        throw new Error('File size is too large (more than 350mb)');\n      }\n\n      return text;\n    }\n  };\n}\n"],"names":["createInspectorDeviceClass","metroBundler","MetroDeviceClass","ExpoInspectorDevice","_debuggerConnection","handlers","NetworkResponseHandler","PageReloadHandler","VscodeDebuggerGetPossibleBreakpointsHandler","VscodeDebuggerScriptParsedHandler","VscodeDebuggerSetBreakpointByUrlHandler","VscodeRuntimeGetPropertiesHandler","onDeviceMessage","message","info","handler","some","onDebuggerMessage","handleDuplicateDeviceConnection","newDevice","_app","_name","_deviceSocket","close","socket","oldDebugger","removeAllListeners","handleDebuggerConnection","pageId","handleDebuggerConnectionWithType","debuggerType","_processMessageFromDevice","_interceptMessageFromDebugger","request","_fetchText","url","LENGTH_LIMIT_BYTES","response","fetch","ok","Error","status","contentLength","headers","get","Number","text","Buffer","byteLength"],"mappings":"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"}